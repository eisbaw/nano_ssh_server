/* AES-128-CTR Test Vectors
 * Sources: NIST SP 800-38A, RFC 3686
 * Test-Driven Development for AES-128-CTR implementation
 */

#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include "aes128_minimal.h"

typedef struct {
    const char *name;
    const uint8_t key[16];
    const uint8_t iv[16];
    const uint8_t plaintext[64];
    const uint8_t ciphertext[64];
    size_t len;
} aes_test_vector_t;

/* NIST SP 800-38A Test Vector - AES-128 CTR Mode */
static const aes_test_vector_t test_vectors[] = {
    {
        .name = "NIST SP 800-38A F.5.1 - 16 bytes",
        .key = {
            0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6,
            0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c
        },
        .iv = {
            0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,
            0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff
        },
        .plaintext = {
            0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96,
            0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a
        },
        .ciphertext = {
            0x87, 0x4d, 0x61, 0x91, 0xb6, 0x20, 0xe3, 0x26,
            0x1b, 0xef, 0x68, 0x64, 0x99, 0x0d, 0xb6, 0xce
        },
        .len = 16
    },
    {
        .name = "NIST SP 800-38A F.5.2 - 32 bytes",
        .key = {
            0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6,
            0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c
        },
        .iv = {
            0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,
            0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff
        },
        .plaintext = {
            0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96,
            0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,
            0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c,
            0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51
        },
        .ciphertext = {
            0x87, 0x4d, 0x61, 0x91, 0xb6, 0x20, 0xe3, 0x26,
            0x1b, 0xef, 0x68, 0x64, 0x99, 0x0d, 0xb6, 0xce,
            0x98, 0x06, 0xf6, 0x6b, 0x79, 0x70, 0xfd, 0xff,
            0x86, 0x17, 0x18, 0x7b, 0xb9, 0xff, 0xfd, 0xff
        },
        .len = 32
    },
    {
        .name = "NIST SP 800-38A F.5.3 - 48 bytes",
        .key = {
            0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6,
            0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c
        },
        .iv = {
            0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,
            0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff
        },
        .plaintext = {
            0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96,
            0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,
            0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c,
            0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,
            0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11,
            0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef
        },
        .ciphertext = {
            0x87, 0x4d, 0x61, 0x91, 0xb6, 0x20, 0xe3, 0x26,
            0x1b, 0xef, 0x68, 0x64, 0x99, 0x0d, 0xb6, 0xce,
            0x98, 0x06, 0xf6, 0x6b, 0x79, 0x70, 0xfd, 0xff,
            0x86, 0x17, 0x18, 0x7b, 0xb9, 0xff, 0xfd, 0xff,
            0x5a, 0xe4, 0xdf, 0x3e, 0xdb, 0xd5, 0xd3, 0x5e,
            0x5b, 0x4f, 0x09, 0x02, 0x0d, 0xb0, 0x3e, 0xab
        },
        .len = 48
    },
    {
        .name = "NIST SP 800-38A F.5.4 - 64 bytes",
        .key = {
            0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6,
            0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c
        },
        .iv = {
            0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,
            0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff
        },
        .plaintext = {
            0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96,
            0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,
            0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c,
            0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,
            0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11,
            0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef,
            0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17,
            0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10
        },
        .ciphertext = {
            0x87, 0x4d, 0x61, 0x91, 0xb6, 0x20, 0xe3, 0x26,
            0x1b, 0xef, 0x68, 0x64, 0x99, 0x0d, 0xb6, 0xce,
            0x98, 0x06, 0xf6, 0x6b, 0x79, 0x70, 0xfd, 0xff,
            0x86, 0x17, 0x18, 0x7b, 0xb9, 0xff, 0xfd, 0xff,
            0x5a, 0xe4, 0xdf, 0x3e, 0xdb, 0xd5, 0xd3, 0x5e,
            0x5b, 0x4f, 0x09, 0x02, 0x0d, 0xb0, 0x3e, 0xab,
            0x1e, 0x03, 0x1d, 0xda, 0x2f, 0xbe, 0x03, 0xd1,
            0x79, 0x21, 0x70, 0xa0, 0xf3, 0x00, 0x9c, 0xee
        },
        .len = 64
    },
    {
        .name = "Zero key, zero IV, zero plaintext",
        .key = {0},
        .iv = {0},
        .plaintext = {0},
        .ciphertext = {
            0x66, 0xe9, 0x4b, 0xd4, 0xef, 0x8a, 0x2c, 0x3b,
            0x88, 0x4c, 0xfa, 0x59, 0xca, 0x34, 0x2b, 0x2e
        },
        .len = 16
    }
};

int main(void) {
    int passed = 0;
    int failed = 0;
    int total = sizeof(test_vectors) / sizeof(test_vectors[0]);

    printf("=== AES-128-CTR Test Vectors ===\n");
    printf("Running %d test vectors...\n\n", total);

    for (int i = 0; i < total; i++) {
        const aes_test_vector_t *tv = &test_vectors[i];
        uint8_t output[64];
        aes128_ctr_ctx ctx;

        /* Copy plaintext to output buffer */
        memcpy(output, tv->plaintext, tv->len);

        /* Encrypt */
        aes128_ctr_init(&ctx, tv->key, tv->iv);
        aes128_ctr_crypt(&ctx, output, tv->len);

        /* Verify */
        if (memcmp(output, tv->ciphertext, tv->len) == 0) {
            printf("[PASS] %s\n", tv->name);
            passed++;
        } else {
            printf("[FAIL] %s\n", tv->name);
            printf("  Expected: ");
            for (size_t j = 0; j < tv->len; j++) {
                printf("%02x", tv->ciphertext[j]);
            }
            printf("\n  Got:      ");
            for (size_t j = 0; j < tv->len; j++) {
                printf("%02x", output[j]);
            }
            printf("\n");
            failed++;
        }

        /* Test decryption (CTR mode: encryption = decryption) */
        memcpy(output, tv->ciphertext, tv->len);
        aes128_ctr_init(&ctx, tv->key, tv->iv);
        aes128_ctr_crypt(&ctx, output, tv->len);

        if (memcmp(output, tv->plaintext, tv->len) == 0) {
            printf("[PASS] %s (decryption)\n", tv->name);
            passed++;
        } else {
            printf("[FAIL] %s (decryption)\n", tv->name);
            failed++;
        }
    }

    printf("\n=============================\n");
    printf("Results: %d passed, %d failed out of %d tests\n", 
           passed, failed, total * 2);
    printf("=============================\n");

    return (failed == 0) ? 0 : 1;
}
