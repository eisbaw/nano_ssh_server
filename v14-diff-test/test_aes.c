/*
 * Test program for AES-128-CTR implementation
 * Verifies against test vectors generated by OpenSSL
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "aes128_minimal.h"

int tests_passed = 0;
int tests_failed = 0;

void print_hex(const char *label, const uint8_t *data, size_t len) {
    printf("%s: ", label);
    for (size_t i = 0; i < len; i++) {
        printf("%02x", data[i]);
    }
    printf("\n");
}

void hex_to_bytes(const char *hex, uint8_t *bytes, size_t len) {
    for (size_t i = 0; i < len; i++) {
        sscanf(hex + i * 2, "%2hhx", &bytes[i]);
    }
}

int test_aes_ctr(int test_num,
                 const char *key_hex,
                 const char *iv_hex,
                 const char *plaintext_hex,
                 const char *expected_hex,
                 size_t len) {
    uint8_t key[16];
    uint8_t iv[16];
    uint8_t plaintext[256];
    uint8_t expected[256];
    uint8_t result[256];
    aes128_ctr_ctx ctx;

    printf("\n=== Test %d ===\n", test_num);

    /* Convert hex strings to bytes */
    hex_to_bytes(key_hex, key, 16);
    hex_to_bytes(iv_hex, iv, 16);
    hex_to_bytes(plaintext_hex, plaintext, len);
    hex_to_bytes(expected_hex, expected, len);

    /* Copy plaintext to result buffer */
    memcpy(result, plaintext, len);

    /* Initialize AES-CTR context */
    aes128_ctr_init(&ctx, key, iv);

    /* Encrypt */
    aes128_ctr_crypt(&ctx, result, len);

    /* Print results */
    print_hex("Key", key, 16);
    print_hex("IV", iv, 16);
    print_hex("Plaintext", plaintext, len);
    print_hex("Expected", expected, len);
    print_hex("Got", result, len);

    /* Compare */
    if (memcmp(result, expected, len) == 0) {
        printf("✓ PASS\n");
        tests_passed++;
        return 1;
    } else {
        printf("✗ FAIL\n");
        tests_failed++;
        return 0;
    }
}

int main() {
    printf("AES-128-CTR Implementation Tests\n");
    printf("=================================\n");

    /* Test vectors from OpenSSL */

    // Test 1: All zeros
    test_aes_ctr(1,
        "00000000000000000000000000000000",
        "00000000000000000000000000000000",
        "00000000000000000000000000000000",
        "66e94bd4ef8a2c3b884cfa59ca342b2e",
        16);

    // Test 2: Sequential bytes
    test_aes_ctr(2,
        "000102030405060708090a0b0c0d0e0f",
        "00000000000000000000000000000000",
        "00112233445566778899aabbccddeeff",
        "c6b01904c3da3df5e7d62bd96d153686",
        16);

    // Test 3: Known NIST test vector
    test_aes_ctr(3,
        "2b7e151628aed2a6abf7158809cf4f3c",
        "f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff",
        "6bc1bee22e409f96e93d7e117393172a",
        "874d6191b620e3261bef6864990db6ce",
        16);

    // Test 4: Multiple blocks (32 bytes)
    test_aes_ctr(4,
        "2b7e151628aed2a6abf7158809cf4f3c",
        "f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff",
        "6bc1bee22e409f96e93d7e117393172aae2d8a571e03ac9c9eb76fac45af8e51",
        "874d6191b620e3261bef6864990db6ce9806f66b7970fdff8617187bb9fffdff",
        32);

    // Test 5: SSH packet-like (48 bytes)
    test_aes_ctr(5,
        "0123456789abcdeffedcba9876543210",
        "00000000000000000000000000000001",
        "000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f",
        "dd1e65d10facc1c0cf7d3741963a1ed74bfdb745d49f7edb7c62b67068d09f082c94a6b23f5373dfb1a5862b1ef5efb5",
        48);

    // Test 6: Non-aligned length (23 bytes)
    test_aes_ctr(6,
        "2b7e151628aed2a6abf7158809cf4f3c",
        "00000000000000000000000000000000",
        "48656c6c6f2c204145532d3132382d4354522100000000",
        "359207607594b9f27b11dd768b23792c03405c4034b1be",
        23);

    /* Print summary */
    printf("\n");
    printf("=================================\n");
    printf("Tests passed: %d\n", tests_passed);
    printf("Tests failed: %d\n", tests_failed);
    printf("=================================\n");

    if (tests_failed == 0) {
        printf("✓ All tests passed!\n");
        return 0;
    } else {
        printf("✗ Some tests failed!\n");
        return 1;
    }
}
