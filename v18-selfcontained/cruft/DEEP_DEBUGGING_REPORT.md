# Deep Debugging Report: OpenSSH Signature Rejection Mystery

## Executive Summary

After exhaustive testing, we have conclusively proven that:
1. ✅ c25519 and libsodium are cryptographically compatible
2. ✅ All signature verification methods work correctly in isolation
3. ✅ The compatibility layer produces valid signatures
4. ❌ OpenSSH still rejects signatures from the hybrid server

This indicates a subtle protocol-level issue, NOT a cryptographic incompatibility.

## Test Results Matrix

| Test | Method | Result |
|------|--------|--------|
| c25519 verifies own signature | edsign_verify() | ✅ PASS |
| libsodium verifies c25519 sig | crypto_sign_ed25519_verify_detached() | ✅ PASS |
| libsodium "open" c25519 sig | crypto_sign_ed25519_open() | ✅ PASS |
| Same seed → same signatures | byte-for-byte comparison | ✅ MATCH |
| Compat layer generates keys | crypto_sign_keypair() | ✅ PASS |
| Compat layer signs | crypto_sign_detached() | ✅ PASS |
| libsodium verifies compat sig | OpenSSH-style verification | ✅ PASS |
| Using actual server keys | All verification methods | ✅ PASS |
| **Actual SSH exchange** | OpenSSH client | ❌ **FAIL** |

## Detailed Test Evidence

### Test 1: Basic Compatibility (test_sig_compat.c)
**Verdict:** ✅ PASS

```
Generated key with c25519:
Signature (c25519): f47461fe49297a6166a0f8e41cb84d80...
c25519 verifies c25519 sig: ✅ PASS
libsodium verifies c25519 sig: ✅ PASS
✅ Libsodium CAN verify c25519 signatures.
```

**Conclusion:** Fundamental compatibility exists.

### Test 2: Key Format Verification (test_key_format.c)
**Verdict:** ✅ PASS

```
Using raw 32-byte seed:
Public keys match: ✅ YES
c25_pk matches ls_sk[32:64]: ✅ YES
seed matches ls_sk[0:32]: ✅ YES
Signatures match: ✅ YES
```

**Conclusion:** Key formats are identical. Both store seed in [0:32] and public key in [32:64].

### Test 3: OpenSSH Verification Method (test_openssh_verify.c)
**Verdict:** ✅ PASS

This test reproduces exactly how OpenSSH verifies signatures using `crypto_sign_ed25519_open()`:

```c
memcpy(sm, c25_sig, 64);           // signature first
memcpy(sm + 64, msg, msg_len);     // then message
int ret = crypto_sign_ed25519_open(m, &mlen, sm, smlen, c25_pk);
```

Result:
```
=== Test 2: c25519 key, c25519 sign, libsodium verify (OpenSSH-style) ===
crypto_sign_ed25519_open result: 0
Verification: ✅ PASS
```

**Conclusion:** Even OpenSSH's specific verification method works with c25519 signatures.

### Test 4: Exact Server Flow Reproduction (test_exact_server_flow.c)
**Verdict:** ✅ PASS

Reproduced the EXACT compatibility layer code:
- `my_crypto_sign_keypair()` - identical to sodium_compat.h
- `my_crypto_sign_detached()` - identical to sodium_compat.h

Result:
```
pk matches sk[32:64]: ✅ YES
crypto_sign_ed25519_verify_detached: ✅ PASS
crypto_sign_ed25519_open: ✅ PASS
✅ Everything works! Bug must be elsewhere.
```

**Conclusion:** The compatibility layer implementation is correct.

### Test 5: Actual Server Keys (test_actual_keys.c)
**Verdict:** ✅ PASS

Used the EXACT keys generated by the running server:
```
Public key: 493db08fb13ed6f4b3b60de03f2e978bb1bb6e9fa97edd6b125556e2681599f2
Secret[0:32]: e3e8e971e6179dc91d511c03fc1a5b005b33c913b58099403d514a513a3b3171
```

Result:
```
c25519 verifies: ✅
libsodium verify_detached: ✅
libsodium crypto_sign_ed25519_open: ✅
```

**Conclusion:** The actual keys being used are valid and produce verifiable signatures.

### Test 6: Actual SSH Exchange
**Verdict:** ❌ FAIL

```
debug2: ssh_ed25519_verify: crypto_sign_ed25519_open failed: -1
ssh_dispatch_run_fatal: Connection to 127.0.0.1 port 2222: incorrect signature
```

Server log shows:
```
Self-verification: PASS    ← c25519's verify accepts it!
Signature: f0684a358096526bd19f26c606b614e3...
sig_blob (83 bytes): 0000000b7373682d6564...
```

**Conclusion:** Something in the actual SSH protocol exchange causes OpenSSH to reject the signature, despite all cryptographic operations being provably correct.

## OpenSSH Source Code Analysis

From `ssh-ed25519.c` in OpenSSH, the verification process is:

```c
// Extract signature from SSH packet
sshbuf_get_string_direct(b, &sigblob, &len);  // len = 64 bytes

// Concatenate signature + data
memcpy(sm, sigblob, len);           // signature (64 bytes)
memcpy(sm+len, data, dlen);         // exchange hash (32 bytes)

// Verify using "open" method
ret = crypto_sign_ed25519_open(m, &mlen, sm, smlen, key->ed25519_pk);
```

Our tests prove this method works with c25519 signatures, yet OpenSSH rejects them.

## Possible Explanations

### Theory 1: Public Key Mismatch ❓
- OpenSSH might be using a different public key for verification than we used for signing
- Need to verify: Does the public key in K_S match sk[32:64]?
- Our logs show they should match, but need explicit verification

### Theory 2: Exchange Hash Mismatch ❓
- OpenSSH might be computing the exchange hash differently
- Need to verify: Exact inputs to compute_exchange_hash()
- Compare byte-for-byte between v14+libsodium (works) and v14+c25519 (fails)

### Theory 3: Hidden libsodium Dependency ❓
- Perhaps OpenSSH is using a bundled Ed25519 implementation, not libsodium
- This implementation might have subtle incompatibilities with c25519
- Our tests use system libsodium, but OpenSSH might use something else

### Theory 4: Packet Parsing Issue ❓
- Maybe the sig_blob format is slightly wrong
- OpenSSH might be extracting the wrong bytes
- Need to capture actual TCP packets and compare byte-by-byte

### Theory 5: Timing/State Issue ❓
- Perhaps something about the connection state affects verification
- Maybe ephemeral key exchange state interferes
- Would explain why offline tests pass but live SSH fails

## Comparison: Working vs Failing

### v14-crypto (libsodium) - WORKS ✅
```
Exchange hash H: 971852118da192565652e33dfd312951e7b3e95c13895426e917d2cba9ecf854
Signature: 4c920b87e5337e5461cada57b9a1eed70b5fba1ca31fc2401516cf3897358d35...
Result: Reaches authentication (password prompt)
```

### v17-from14 (c25519) - FAILS ❌
```
Exchange hash H: 68acfbbecd817b59c9c22c90c3b054be077913e95cd44aec89c4853093e76db5
Self-verification: PASS
Signature: 84facc64d5381c550dfc0c856e2b442e58b05c9aa135d5634f0977ff458c5420...
Result: "incorrect signature"
```

Note: Different exchange hashes because keys are randomly generated each run.

## Binary Analysis

```
$ ldd nano_ssh_server
linux-vdso.so.1
libc.so.6
/lib64/ld-linux-x86-64.so.2
```

✅ Confirmed: NO libsodium dependency in the binary.

## Next Investigation Steps

### Recommended Approach 1: Capture & Compare Packets
1. Run v14-crypto server
2. Capture SSH exchange with tcpdump
3. Run v17-from14 server
4. Capture SSH exchange
5. Compare KEX_ECDH_REPLY packets byte-for-byte

### Recommended Approach 2: Add Exchange Hash Validation
1. Have server print exact bytes used for exchange hash computation
2. Capture OpenSSH's verbose output showing what it receives
3. Compare to ensure they match

### Recommended Approach 3: Test with Different OpenSSH Build
1. Compile OpenSSH with debug symbols
2. Add logging to ssh_ed25519_verify function
3. See exactly what data OpenSSH is trying to verify

### Recommended Approach 4: Minimal Diff Testing
1. Start with v14-crypto (working)
2. Replace ONLY crypto_sign_keypair with compat version
3. Test
4. Replace ONLY crypto_sign_detached
5. Test
6. Identify exact function causing issue

## Files Created During Investigation

- `sodium_compat.h` - Compatibility layer (appears correct)
- `test_sig_compat.c` - Proves basic compatibility ✅
- `test_key_format.c` - Proves key format compatibility ✅
- `test_openssh_verify.c` - Proves OpenSSH method works ✅
- `test_exact_server_flow.c` - Proves compat layer works ✅
- `test_actual_keys.c` - Proves server keys are valid ✅
- `test_cross_verify.c` - Proves cross-verification works ✅

## Conclusion

We have reached a paradoxical situation:

**ALL standalone tests prove the system should work**, yet **the actual SSH exchange fails**.

This strongly suggests:
1. The bug is NOT in the cryptographic implementations
2. The bug is NOT in the compatibility layer
3. The bug is NOT in key generation or signature creation
4. The bug IS somewhere in the SSH protocol flow or packet formatting

The most likely explanations are:
- A subtle mismatch in the exchange hash computation
- A packet formatting issue that affects how OpenSSH extracts the signature
- OpenSSH using a different Ed25519 implementation than system libsodium

**Recommended next step:** Byte-level packet comparison between working and failing versions.
