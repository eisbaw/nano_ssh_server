/* Test with the actual keys generated by the server */
#include <stdio.h>
#include <string.h>
#include <sodium.h>
#include "edsign.h"

int main() {
    /* Initialize libsodium */
    if (sodium_init() < 0) {
        printf("libsodium init failed\n");
        return 1;
    }

    /* Use the EXACT keys from the server log */
    uint8_t pk[32] = {
        0x49,0x3d,0xb0,0x8f,0xb1,0x3e,0xd6,0xf4,0xb3,0xb6,0x0d,0xe0,0x3f,0x2e,0x97,0x8b,
        0xb1,0xbb,0x6e,0x9f,0xa9,0x7e,0xdd,0x6b,0x12,0x55,0x56,0xe2,0x68,0x15,0x99,0xf2
    };

    uint8_t sk[64] = {
        // First 32 bytes (secret)
        0xe3,0xe8,0xe9,0x71,0xe6,0x17,0x9d,0xc9,0x1d,0x51,0x1c,0x03,0xfc,0x1a,0x5b,0x00,
        0x5b,0x33,0xc9,0x13,0xb5,0x80,0x99,0x40,0x3d,0x51,0x4a,0x51,0x3a,0x3b,0x31,0x71,
        // Second 32 bytes (public)
        0x49,0x3d,0xb0,0x8f,0xb1,0x3e,0xd6,0xf4,0xb3,0xb6,0x0d,0xe0,0x3f,0x2e,0x97,0x8b,
        0xb1,0xbb,0x6e,0x9f,0xa9,0x7e,0xdd,0x6b,0x12,0x55,0x56,0xe2,0x68,0x15,0x99,0xf2
    };

    printf("Using server's keys:\n");
    printf("  Public key: ");
    for (int i = 0; i < 32; i++) printf("%02x", pk[i]);
    printf("\n\n");

    /* Sign with c25519 (as server does) */
    const char *msg = "Test exchange hash";
    size_t msg_len = strlen(msg);

    uint8_t c25_sig[64];
    edsign_sign(c25_sig, sk + 32, sk, (uint8_t*)msg, msg_len);

    printf("c25519 signature: ");
    for (int i = 0; i < 16; i++) printf("%02x", c25_sig[i]);
    printf("...\n");

    /* Verify with c25519 */
    uint8_t c25_verify = edsign_verify(c25_sig, pk, (uint8_t*)msg, msg_len);
    printf("c25519 verifies: %s\n", c25_verify ? "✅" : "❌");

    /* Verify with libsodium detached */
    int ls_detached = crypto_sign_ed25519_verify_detached(c25_sig, (uint8_t*)msg, msg_len, pk);
    printf("libsodium verify_detached: %s\n", ls_detached == 0 ? "✅" : "❌");

    /* Verify OpenSSH-style with crypto_sign_ed25519_open */
    size_t smlen = 64 + msg_len;
    uint8_t *sm = malloc(smlen);
    uint8_t *m = malloc(smlen);
    unsigned long long mlen = smlen;

    memcpy(sm, c25_sig, 64);
    memcpy(sm + 64, msg, msg_len);

    int open_result = crypto_sign_ed25519_open(m, &mlen, sm, smlen, pk);
    printf("libsodium crypto_sign_ed25519_open: %s\n", open_result == 0 ? "✅" : "❌");

    if (open_result != 0) {
        printf("\n❌ Failed with server's actual keys!\n");
    }

    free(sm);
    free(m);

    return 0;
}
