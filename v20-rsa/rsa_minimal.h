/*
 * Minimal RSA Implementation for SSH
 * PKCS#1 v1.5 signatures with SHA-256
 * Public domain implementation
 */

#ifndef RSA_MINIMAL_H
#define RSA_MINIMAL_H

#include "bigint.h"
#include "sha256_minimal.h"
#include "random_minimal.h"

#define RSA_KEY_BITS 2048
#define RSA_KEY_BYTES (RSA_KEY_BITS / 8)

/* Standard public exponent */
#define RSA_PUBLIC_EXPONENT 65537

/* RSA key structure */
typedef struct {
    bigint_t n;  /* Modulus */
    bigint_t e;  /* Public exponent */
    bigint_t d;  /* Private exponent */
} rsa_key_t;

/* PKCS#1 v1.5 DigestInfo for SHA-256 */
static const uint8_t sha256_digest_info[] = {
    0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86,
    0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05,
    0x00, 0x04, 0x20
};

/* Generate simple RSA key (NOT cryptographically secure - for demo only!) */
static void rsa_generate_key_simple(rsa_key_t *key) {
    /* For a minimal implementation, use hardcoded primes */
    /* In production, you'd generate random primes using Miller-Rabin */

    /* This is a SIMPLIFIED version - using small primes for demonstration */
    /* Real implementation needs proper prime generation */

    /* Set public exponent */
    bigint_set_u64(&key->e, RSA_PUBLIC_EXPONENT);

    /* For this demo, we'll use a pre-generated 2048-bit modulus and private exponent */
    /* In production, generate p, q, compute n=p*q, d=e^-1 mod phi(n) */

    /* Placeholder: zero out for now - will be set properly below */
    bigint_zero(&key->n);
    bigint_zero(&key->d);
}

/* Load hardcoded RSA key (for testing/demo) */
static void rsa_load_hardcoded_key(rsa_key_t *key) {
    /* This is a pre-generated 2048-bit RSA key for testing */
    /* Modulus (n) - 2048 bits */
    static const uint8_t n_bytes[256] = {
        0xc4, 0x7a, 0xba, 0xcc, 0x2a, 0x84, 0xd5, 0x6f,
        0x73, 0x71, 0xd4, 0x55, 0xf9, 0x70, 0xb5, 0xea,
        0x8c, 0xbf, 0xb1, 0x5d, 0xfb, 0xc5, 0xb6, 0xfd,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03
    };

    /* Private exponent (d) - simplified for demo */
    static const uint8_t d_bytes[256] = {
        0x8f, 0x4e, 0x7c, 0x88, 0x1c, 0x57, 0x8e, 0x4a,
        0x4e, 0x4b, 0x8d, 0x37, 0xa7, 0x63, 0x78, 0x9d,
        0x5e, 0x3f, 0x76, 0x3e, 0xa8, 0x83, 0x79, 0xfe,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02
    };

    bigint_from_bytes(&key->n, n_bytes, sizeof(n_bytes));
    bigint_from_bytes(&key->d, d_bytes, sizeof(d_bytes));
    bigint_set_u64(&key->e, RSA_PUBLIC_EXPONENT);
}

/* Sign message with RSA (PKCS#1 v1.5 padding) */
static int rsa_sign(uint8_t *signature, int *sig_len, const uint8_t *message, int msg_len, const rsa_key_t *key) {
    uint8_t hash[32];
    uint8_t padded[RSA_KEY_BYTES];
    bigint_t m, s;

    /* Hash the message */
    sha256(hash, message, msg_len);

    /* PKCS#1 v1.5 padding */
    /* Format: 0x00 || 0x01 || PS || 0x00 || DigestInfo || Hash */
    int digestinfo_len = sizeof(sha256_digest_info);
    int hash_len = 32;
    int ps_len = RSA_KEY_BYTES - 3 - digestinfo_len - hash_len;

    if (ps_len < 8) return -1; /* Padding too short */

    int pos = 0;
    padded[pos++] = 0x00;
    padded[pos++] = 0x01;

    /* Padding string (0xFF bytes) */
    for (int i = 0; i < ps_len; i++) {
        padded[pos++] = 0xFF;
    }

    padded[pos++] = 0x00;

    /* DigestInfo */
    memcpy(padded + pos, sha256_digest_info, digestinfo_len);
    pos += digestinfo_len;

    /* Hash */
    memcpy(padded + pos, hash, hash_len);

    /* Convert to bigint */
    bigint_from_bytes(&m, padded, RSA_KEY_BYTES);

    /* Sign: s = m^d mod n */
    bigint_modexp(&s, &m, &key->d, &key->n);

    /* Convert to bytes */
    bigint_to_bytes(signature, RSA_KEY_BYTES, &s);
    *sig_len = RSA_KEY_BYTES;

    return 0;
}

/* Verify RSA signature */
static int rsa_verify(const uint8_t *signature, int sig_len, const uint8_t *message, int msg_len, const rsa_key_t *key) {
    uint8_t hash[32];
    uint8_t decrypted[RSA_KEY_BYTES];
    bigint_t s, m;

    if (sig_len != RSA_KEY_BYTES) return -1;

    /* Hash the message */
    sha256(hash, message, msg_len);

    /* Convert signature to bigint */
    bigint_from_bytes(&s, signature, sig_len);

    /* Decrypt: m = s^e mod n */
    bigint_modexp(&m, &s, &key->e, &key->n);

    /* Convert to bytes */
    bigint_to_bytes(decrypted, RSA_KEY_BYTES, &m);

    /* Verify PKCS#1 v1.5 padding */
    int pos = 0;
    if (decrypted[pos++] != 0x00) return -1;
    if (decrypted[pos++] != 0x01) return -1;

    /* Skip padding (0xFF bytes) */
    while (pos < RSA_KEY_BYTES && decrypted[pos] == 0xFF) {
        pos++;
    }

    if (pos >= RSA_KEY_BYTES || decrypted[pos++] != 0x00) return -1;

    /* Check DigestInfo */
    if (memcmp(decrypted + pos, sha256_digest_info, sizeof(sha256_digest_info)) != 0) return -1;
    pos += sizeof(sha256_digest_info);

    /* Verify hash */
    if (memcmp(decrypted + pos, hash, 32) != 0) return -1;

    return 0;
}

#endif /* RSA_MINIMAL_H */
